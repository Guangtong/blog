<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[swdev.online]]></title>
  <link href="https://swdev.online/atom.xml" rel="self"/>
  <link href="https://swdev.online/"/>
  <updated>2020-07-03T19:45:19-07:00</updated>
  <id>https://swdev.online/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Idempotency of a PUT Request]]></title>
    <link href="https://swdev.online/idempotency-of-a-put-request.html"/>
    <updated>2020-07-02T01:15:34-07:00</updated>
    <id>https://swdev.online/idempotency-of-a-put-request.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1. How To Avoid Duplicate Order</a>
<ul>
<li>
<a href="#toc_1">E-commerce Scenario - Common Flow of Placing Order</a>
</li>
<li>
<a href="#toc_2">Cause:</a>
</li>
<li>
<a href="#toc_3">Solution 1: One-time token</a>
</li>
<li>
<a href="#toc_4">Solution 2: Leverage DB Primary Key uniqueness</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">2. In general how to guarantee Idempotence of an API put request.</a>
</li>
<li>
<a href="#toc_6">Action Items</a>
</li>
</ul>


<h2 id="toc_0">1. How To Avoid Duplicate Order</h2>

<h3 id="toc_1">E-commerce Scenario - Common Flow of Placing Order</h3>

<ul>
<li>Go to Cart</li>
<li>Cart Page + Checkout button </li>
<li>Checkout Page + Place order button </li>
<li>Payment: <br/>
US E-commerce has no such step - Credit card or PayPal are filled in Checkout Page.</li>
<li>Success Page</li>
</ul>

<span id="more"></span><!-- more -->

<h3 id="toc_2">Cause:</h3>

<ul>
<li>User clicks PlaceOrder multiple times</li>
<li>Backend retries the call to Order service</li>
</ul>

<h3 id="toc_3">Solution 1: One-time token</h3>

<ul>
<li>Checkout page requests one-time token</li>
<li>Store token in Redis as Key.
<ul>
<li>Set expired time in case there is no order placed.</li>
<li><a href="https://redis.io/commands/pexpire">PEXPIRE token 5000</a></li>
</ul></li>
<li>Place order request comes with the token</li>
<li>Order system verifies token by
<ul>
<li><a href="https://redis.io/commands/del">DEL token</a></li>
<li>Return 0 means the key is already removed.</li>
</ul></li>
</ul>

<p>Assessment: </p>

<ul>
<li>Scalability: High. 
<ul>
<li>Redis Sharding.</li>
</ul></li>
<li>Availability: High.
<ul>
<li>Service is down after DEL token: retries will fail. Place order will fail. </li>
<li>Redis node is down. Token not available, place order will fail. </li>
</ul></li>
</ul>

<h3 id="toc_4">Solution 2: Leverage DB Primary Key uniqueness</h3>

<ul>
<li>Checkout page requests orderId</li>
<li>Place order request comes with the orderId</li>
<li>DB creates order using orderId as primary key. </li>
<li>Insert failure means PK already exists, this is a duplicate request. </li>
</ul>

<p>Assessment: </p>

<ul>
<li>Scalability: High</li>
<li>Availability: Depends on proxy. If using consistent hashing which can remove the failure node, then it&#39;s high.</li>
<li>Security: Attacker can use invalid key, we have to verify it.</li>
</ul>

<h2 id="toc_5">2. In general how to guarantee Idempotence of an API put request.</h2>

<pre><code class="language-sql">INSERT INTO users (uid, age, gender, createTime)
VALUES (1234567, 20, &quot;male&quot;, 1593684708)
</code></pre>

<p>Can we assume all INSERTS are idempotent when there is a Primary Key? </p>

<ul>
<li>No if we use AutoGenerated ID
<ul>
<li>MySQL <a href="https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html">AUTO_INCREMENT</a></li>
<li>DynamoDB <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.Annotations.html#DynamoDBMapper.Annotations.DynamoDBAutoGeneratedKey">@DynamoDBAutoGeneratedKey</a> UUID is 128bit in Memory, but in DB it&#39;s a <a href="https://docs.oracle.com/javase/6/docs/api/java/util/UUID.html#toString()">string</a> of 32 chars and 4 &quot;-&quot;.</li>
<li>MongoDB <a href="https://docs.mongodb.com/manual/reference/bson-types/#objectid">ObjectId</a> ObjectId, 12bytes number in BSON.</li>
</ul></li>
</ul>

<p>Can we guarantee idempotency if we provide Primary Key from outside system and guarantees uniqueness. </p>

<ul>
<li>Note that DDB and MongoDB generate UUID or ObjectId at client side ! The retry of DB access can use the same ID! Using an IDGenerator service doesn&#39;t help!</li>
<li>Therefore it&#39;s not the problem of DB retry, but the problem of API retry from up stream.</li>
</ul>

<p><strong>Conclusion</strong>: I didn&#39;t find other work-arounds, except for the above Solution 1 and 2 - the top level caller requests downstream services with a unique token / Primary Key. <br/>
This might not be feasible if top level caller is not owned by yourself and it wants to retry.</p>

<h2 id="toc_6">Action Items</h2>

<ul>
<li><p>Review Replication</p>
<ul>
<li>master-slave vs master-master
<ul>
<li>How DDB guarantees <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html#WorkingWithItems.AtomicCounters">Atomic update</a>? <br/>
I think it must lock 3 replicas.<br/></li>
</ul></li>
<li>synchronous vs asynchronous</li>
</ul></li>
<li><p>Review Redis sharding</p>
<ul>
<li>Range partition</li>
<li>Hash partition</li>
</ul></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Twitter - 1: Requirement and Storage Selection]]></title>
    <link href="https://swdev.online/design-twitter-using-no-sql-1.html"/>
    <updated>2019-11-09T14:47:01-08:00</updated>
    <id>https://swdev.online/design-twitter-using-no-sql-1.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1. Requirement</a>
<ul>
<li>
<a href="#toc_1">1.1 Use Case</a>
</li>
<li>
<a href="#toc_2">1.2 Volume</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">2. System Design</a>
<ul>
<li>
<a href="#toc_4">2.1 API</a>
</li>
<li>
<a href="#toc_5">2.2 Storage Choice</a>
<ul>
<li>
<a href="#toc_6">2.2.1 RDBMS</a>
</li>
<li>
<a href="#toc_7">2.2.2 NoSQL</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">1. Requirement</h2>

<h3 id="toc_1">1.1 Use Case</h3>

<p>As a user</p>

<pre><code class="language-text">I can create my profile
I can post a tweet
I can list my tweets posted before
I can follow / unfollow other users
I can list my followers and my followees
I can see others tweets in my homepage timeline
I can see my own tweets in my profile timeline
I can read a tweet (unlike facebook, you don&#39;t  need to click into the message.)
I can delete my tweets, so that no one can see it any more. 
</code></pre>

<p>NOTE: If this is an interview, you&#39;d better list some common use cases, but pick one or two key use cases to go in depth. Time slips away quickly when you explain a design. You want to show the breadth and depth of your knowledge.</p>

<span id="more"></span><!-- more -->

<h3 id="toc_2">1.2 Volume</h3>

<p>Ask for TPS from your interviewer, unless he asks you to estimate it. </p>

<p>A useful way is to start from MAU or DAU based on US population and the relative size of each use case. </p>

<p>It took me 20 minutes to think about the TPS of each use case below. This is absolutely not feasible in an interview. So in reality, we should go with just the read and write of one use case or two.</p>

<p>Your interviewer would like to see how you estimates, not the accurate number. So I intend not to go too high for the DAU. On one hand, You may trap yourself into an over-challenging problem. On the other hand, we can start with US market first, and if we still have time, we can think about scaling it to EU and FE by replication. </p>

<ul>
<li>MAU: 2% US people - 60 Million</li>
<li><p>DAU: 1/3 MAU - 20 Million <sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></p></li>
<li><p>TPS</p></li>
</ul>

<table>
<thead>
<tr>
<th>API</th>
<th>Peak TPS</th>
<th style="text-align: right">Reason</th>
</tr>
</thead>

<tbody>
<tr>
<td>Show timeline (read tweets)</td>
<td>10k</td>
<td style="text-align: right">Assume every DAU access it twice with one refresh. <br>20e6 * 4 / (24 * 60 * 60) ~ 1000. <br>Consider peak hours and peak events, we give it 10 times buffer.</td>
</tr>
<tr>
<td>Post a tweet</td>
<td>100</td>
<td style="text-align: right">1% of read.</td>
</tr>
<tr>
<td>Comment a tweet</td>
<td>1k</td>
<td style="text-align: right">10 times of post.</td>
</tr>
<tr>
<td>Delete a tweet</td>
<td>10</td>
<td style="text-align: right">Rare</td>
</tr>
<tr>
<td>List my tweets</td>
<td>10</td>
<td style="text-align: right">Rare</td>
</tr>
<tr>
<td>Follow a user</td>
<td>100</td>
<td style="text-align: right">1% of read</td>
</tr>
<tr>
<td>Unfollow a user</td>
<td>10</td>
<td style="text-align: right">Rare</td>
</tr>
<tr>
<td>List my followers</td>
<td>100</td>
<td style="text-align: right">Same as follow</td>
</tr>
<tr>
<td>List my followees</td>
<td>100</td>
<td style="text-align: right">Same as list followers</td>
</tr>
</tbody>
</table>

<ul>
<li>Storage<br/>
600 Million entries in user table (Assume 10% of all users are MAU)<br/>
315 Million tweets per year (10% of Peak post TPS is 10. 10 * 365 * 24 * 3600 = 315 M)</li>
</ul>

<h2 id="toc_3">2. System Design</h2>

<h3 id="toc_4">2.1 API</h3>

<p>Each use case can be a RESTFUL API</p>

<h3 id="toc_5">2.2 Storage Choice</h3>

<h4 id="toc_6">2.2.1 RDBMS</h4>

<p>Both user table and tweets table are too big for RDBMS without sharding. Usually one MySQL table is good for &lt; 1M rows. </p>

<p>We can do sharding like this:</p>

<ul>
<li>partition user table based on user id.</li>
<li>partition tweets table based on tweet id.</li>
</ul>

<p>Sharding RDBMS is painful and error prone:</p>

<ul>
<li> Need a proxy layer to route requests. </li>
<li> Cannot access data based on other columns instead of the partition key.</li>
<li> Rescaling is difficult, may need to turn off the whole system.</li>
<li> You cannot do join tables or select columns using flexible where clause.</li>
</ul>

<p>Therefore RDBMS is not considered as scalable.</p>

<h4 id="toc_7">2.2.2 NoSQL</h4>

<p>No SQL is good for this use case - No complex join, No transaction, Eventual consistency is enough.</p>

<p>Hbase/DynamoDB/MongoDb and even Redis will all work. </p>

<p>I&#39;ll talk about my schema design using HBase, DynamoDB and Redis respectively in the next few articles. </p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>World wide DAU in Q4 2018: Facebook 1,520M; Snap 186M; Twitter 126M. Reference: <a href="https://www.vox.com/2019/2/7/18215204/twitter-daily-active-users-dau-snapchat-q4-earnings">https://www.vox.com/2019/2/7/18215204/twitter-daily-active-users-dau-snapchat-q4-earnings</a>&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
</feed>
